Встроенная функция open() создает объект для работы с файлом на компьютере.

file1 = open(r'C:\spam', 'w') -> открывает файл на запись
file1 = open(r'C:\spam', 'r) -> открывает файл на чтение
file1 = open(r'C:\spam') -> открывает файл на чтение
file1 = open(r'C:\spam', 'bк') -> открывает файл в двоичном формате на чтение, отключает трансляцию информации через кодировку

open принимает два обязательных строковых параметра: путь до файла, режим октрытия:

	r - открывает файл только для чтения,
	w - открыт для записи (перед записью файл будет очищен),
	x - эксклюзивное создание, бросается исключение FileExistsError, если файл уже существует.
	a - открыт для добавления в конец файла (на некоторых Unix-системах пишет в конец файла вне зависимости от позиции курсора)
	+ - символ обновления (чтение + запись).
	t - символ текстового режима.
	b - символ двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).

    'r' - Открывает файл только для чтения. Указатель файла помещается в начале файла. Это режим "по умолчанию".
    'rb' - Открывает файл в бинарном режиме только для чтения. Указатель файла помещается в начале файла. Это режим "по умолчанию".
    'r+' - Открывает файл для чтения и записи. Указатель файла помещается в начало файла.
    'rb+' - Открывает файл в бинарном режиме для чтения и записи. Указатель файла помещается в начале файла. Это режим "по умолчанию".
    'w' - Открывает файл только для записи. Перезаписывает файл, если файл существует. Если файл не существует, создает новый файл для записи.
    'wb' - Открывает файл в бинарном режиме только для записи. Перезаписывает файл, если файл существует. Если файл не существует, создает новый файл для записи.
    'w+' - Открывает файл для записи и чтения. Перезаписывает существующий файл, если файл существует. Если файл не существует, создается новый файл для чтения и записи.
    'wb+' - Открывает файл в бинарном режиме для записи и чтения. Перезаписывает существующий файл, если файл существует. Если файл не существует, создается новый файл для чтения и записи.
    'a' - Открывает файл для добавления. Указатель файла находится в конце файла, если файл существует. То есть файл находится в режиме добавления. Если файл не существует, он создает новый файл для записи.
    'ab' - Открывает файл в бинарном режиме для добавления. Указатель файла находится в конце файла, если файл существует. То есть файл находится в режиме добавления. Если файл не существует, он создает новый файл для записи.
    'a+' - Открывает файл для добавления и чтения. Указатель файла находится в конце файла, если файл существует. Файл открывается в режиме добавления. Если файл не существует, он создает новый файл для чтения и записи.
    'ab+' - Открывает файл в бинарном режиме для добавления и чтения. Указатель файла находится в конце файла, если файл существует. Файл открывается в режиме добавления. Если файл не существует, он создает новый файл для чтения и записи.

text = file1.read() -> читает весь файл, складывает в одну строку и возвращает эту строку
text = file1.read(N) -> читакт N символов (или байтов)

text = file1.readline() -> читает первую строку файла. При вызове в том же процессе Python прочитает следующую строку
text = file1.readlines() -> прочитает все строки вернет в виде списка строк. С символами перевода строки

file1.write(stroka) -> запишет переданный объект str в файл
file1.writelines(list_strok) -> запишет все строки из списка в файл

file1.close() -> закрывает файл. Также это делает автоматически сборщик мусора

file1.flush() -> сбрасывает буфер вывода на диск, не закрывая файл

file1.seek(N) -> устанавливает каретку чтения-записи в файле на позицию. По сути, передвигается по строке, представляющей информацию из файла.

По открытому файлу можно итерироваться построчно:

for line in open('testfile.txt'):...

Из файла в достаточной мере удобно читать числа, всего то надо получить строковое представление и запихнуть его в int(), но с другими типами данных это сложнее. Для считывания из файла объектов, можно применять eval():

Пусть в файле file1 лежит исключительно '1, 2, 3'. Возможно практически на лету состряпать кортеж из этого через eval():

a = eval("{open('file1.txt', 'r+').read()}") -> type(a) = set, а print(a) -> {1, 2, 3}

eval может исполнить плохую команду из файла, так что это не самый лучший метод. Помимо этого у eval() другая цель применения. Чуть лучше справляется модуль из стандартной библиотеки pickle. Но в документации к pickle также сказано, что им не стоит десериализировать сомнительные данные из файлов, так как он тоже может испольнить вредоносный код.

Использовать pickle просто:
import pickle
pickle.dump(data, open('file1', 'wb')) # запишет объект data в файл file1
pickle.load(open('file1', 'rb')) -> вернет десериализованное представление из файла file1

pickle пишет данные в бинарном формате, опираясь на бинарный протокол сериализации данных.

Работа с файлами в формате JSON

Для сериализации и десериализации данных формата JSON в Python присутствует модуль json (import json),

Для того, чтобы сериализовать словарь python необходимо записать в файл вывод функции json.dump(data). После того, как информация в файл была записана, её можно десериализовать, применяя функцию json.load(data), передавая ей строку, полученную из файла. Обратно из этой функции вернется тот объект, который был сериализован. Существует ограничение, вызванное форматом JSON: не получится сериализовать множества (set) и кортежи (tuple). Причем, кортеж будет сериализован в виде JavaScript array. А при попытке сериализовать множество, python выдаст ошибку TypeError.

