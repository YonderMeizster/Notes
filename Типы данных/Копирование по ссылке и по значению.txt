В следующем примере кода:

a = 5
b = a

a и b ссылаются на один и тот же объект в памяти. На неизменемую 5 типа int.
Если присвоить переменной a другое значение, то значение b не изменится.

Иная ситуация возникает в слудующем случае:

a = [1, 2, 3]
b = a

Если написать далее:

a[0] = 2

То b станет указывать на список со значениями [2, 2, 3] как и a. Это происходит потому что список поддерживает изменение на месте, как это называет Лутц. Иными словами он содержит ссылки на другие объекты и изменения этих ссылок внутри списка никак не отражается на ссылки в переменных a и b. Такая фишка происходит только с изменяемыми на месте типами данных (это такие обекты, которые при изменении не создаются заново, а лишь видоизменяют уже имеющуюся структуру)

Аналогичная ситуация происходит не только со списками, но со словарями и множествами. А также с пользовательскими классами:

class C1:
    value = 5

a = C1()	# a.value равно 5
b = a		# b.value равно 5

b.value = 1	# a.value равно 1 и b.value равно 1

Для того, чтобы скопировать по значениям список можно использовать срез: [:]. Но так нельзя сделать в отношении словарей и и множеств, по причине того, что срез к ним нельзя применить. Для копирования множеств и срезов следует воспользоваться встроенным в них метода .copy(), этот же метод с версии CPython 3.3 был добавлен и к спискам. А еще можно запихнуть экземпляр списка, множества или словаря в соответствующую функцию list(), set(), dict() (?конструктор их классов?)

В случае возникновения желания копирования по значениям экземпляров пользовательских классов можно воспользоваться функцией copy() из модуля copy:

a = C1()
b = copy.copy(a)

Но функция copy сделает поверхностное копирование. В этом модуле существует еще и другая функция копирования deepcopy(). Функция глубокого копирования позволяет произвести рекурсивное копирования объекта. Это необходимо в случае, если объект содержит ссылки на объекты, которые содержат ссылки.

Например:

import copy

class C1:
    __init__(self):
        value = [1, 2, 3]

a = C1()
b = copy.copy(a)
a.value[0] = 7

print(f'{a.value} {b.value}') -> [7, 2, 3] [7, 2, 3]

Применение deepcopy позволит избежать этого и вывод print() будет другим: [7, 2, 3] [1, 2, 3]


В питоне можно сравнивать равность по разному. Существует две проверки на равенство: == проверяет, одинаковые ли значения содержат в себе переменные, а проверка is проверяет, являются ли операнды одним и тем же объектом