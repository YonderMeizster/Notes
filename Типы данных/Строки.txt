Строки в python 3.* являются неизменяемыми последовательностями, а также упорядоченными коллекциями. Последовательности в питоне куда более обширны, к ним относятся также списки и кортежи. Упорядоченность дает возможность обращаться к элементам строки по индексу.
В некоторых других языках строки представляют собой массив символов (тип char), в пайтон такого нет. Вместо этого существуют строки единичной длины.

В виде строк могут быть представлены три типа данных: str, bytes и bytearray. Последний является изменяемым вариантом типа bytes. str призван хранить в себе текст в кодированном виде, bytes и bytearray хранят "сырые" байты, которые можно кодировать с применением какой- нибудь кодировки и получить строку str.

В примере кода далее показывается, как перевести текст в байты, используя кодировку

>>> stroka = 'йцу'.encode('utf-8')
>>> stroka
b'\xd0\xb9\xd1\x86\xd1\x83' # d0b9 - это шестнадцатеричное значение буквы 'й' в кодировке UTF-8 (UTF-8 является кодировкой переменной длины, так что она не ограничена восемью битами), затем d186 - это 'ц' и наконец d183 - шестнадцатеричное представление буквы 'у'
>>> stroka = stroka.decode('utf-8') # зная, что последовательность бит, лежащая по ссылке переменной stroka имеет смысл в кодировке UTF-8, можно вычленить информацию, проведя декодирование
>>> stroka
'йцу'

>>> stroka = stroka.decode('cp037') # а можно, соответственно, провести декодирование по другой кодировке, в данном случае по cp037 (по ascii нельзя, потому что d0 (208) не помещается в диапазон ascii (0 - 127))
>>> stroka
'}¾JfJc' # был получен какой- то страшный ответ, а все потому что кодировка для декодирования была выбрана неправильно

Все методы строк не меняют свой экземпляр, вместо этого они возвращают новый измененный

'asb  '.rstrip() 		-> возвращает строку, у которой удалены все пробелы с конца. Если передать строку, то с конца удалятся только те, которые есть в этой строке
'abcdef'.rstrip('ef') 		-> 'abcd', а также 'abcdef'.rstrip('fe') -> 'abcd'. То есть порядок не важен. Также: 'abcdefgfggggfgfggf'.rstrip('gf') -> 'abcde'

stroka.find('a') 		-> вернет индекс первого вхождения 'a' в stroka. Иначе вернет -1

stroka.replace('a', 'b') 	-> заменит все символы 'a' на 'b' и вернет новую строку

stroka.isdigit() 		-> вернет True, если строка целиком состоит из цифр

stroka.isalpha() 		-> вернет True, если строка целиком состоит из цифр и букв

stroka.isalnum() 		-> вернет True, если строка состоит только из цифр и букв

stroka.endswith('a') 		-> вернет True, если stroka заканчивается на 'a'

stroka.startswith('a') 		-> вернет True, если строка начинается на 'a'

Также по строкам можно итерироваться и брать срез.

Интересно вот, что, пайтон выполняет конкатенацию строк автоматически, если несколько строк написаны вплотную или через пробел:

a = '123' 'abc' 		-> 123abc
b = '123''abc' 'bvc' 		-> 123abcbvc

len(stroka) 			-> вернет длину строки учитывая управляющие символы, такие как \t, \n и другие

r''				-> отключает распознование специальных последовательностей, давая возможность написать \t как \t, а не как табуляцию. Правда, после слеша обязательно должно что- то идти
