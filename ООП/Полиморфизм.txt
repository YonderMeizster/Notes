Python оставляет на усмотрение объектов, что делать с операцией. В питоне поведение зависит от типов, то есть смысл операции зависит от обрабатываемых объектов. Так как пайтон обладает динамической типизацией, практически все в этом языке так или иначе пропитано полиморфизмом. Например, функция print(). Ей что ни скорми, она все сожрет, где- то там внутри сама спросит у объекта метод __str__, а потом сама передаст результаты в системный обработчик. А сам синтаксис от этого не меняется, не важно, выводится в консоль строка, или число, или экземпляр пользовательского класса, лишь чуть меняется внешний вид аргумента.

Одна и та же функция может применяться к множеству объектов ровно до тех пор, пока эти объекты поддерживают требуемый этой функцией интерфейс, он же протокол. То есть реализуют те методы, которые функция ожидает "увидеть" и взывать.

Лутц выражает вот какую мысль: кажется, он советует не проверять типы объектов аргументов функции внутри функции. Так как если аргументы поддерживают интерфейс, треубемый функцией- все пройдет хорошо. А вот если нет, то интерпретатор сам сгенерирует ошибку.

Также Лутц говорит, что именно это и есть ключевое филосовское отличие питона от Java или C++: мой код не обязан заботиться о специфических типах данных. Потому что эта забота приведет к тому, что код будет работать лишь с предсказанными типами данных, но откажется работать с новыми типами данных, возможно, реализуемых в будуещм. В Python код пишется для интерфейсов, а не для типов данных.

Вот это явление "писать код для интерфейса, а не типа", называется утиной типизацией. То есть коду не важно, как выглядит утка, ему важно, чтобы она умела крякать и летать, когда её попросят об этом.