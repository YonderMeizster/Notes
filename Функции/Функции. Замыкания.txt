Для определения новой функции в python используется оператор def. Он является исполняемым оператором. Функция не существует, так сказать, отстуствует в области видимости до тех пор, пока python не встретит и не выполнит def.

Когда python выполняет def, он создает новый объект, представляющий собой функцию и присвает ссылку на него переменной- имени функции. Именно это позволяет присваивать другим переменным функцию.

Оператор lambda является аналогичным оператору def в том отношении, что он является исполняемым. Но lambda создает объект и возвращает его в качестве результата. Не понятно.

Оператор return возвращает результат выполнения функции. Когда в процессе выполнения кода вызывается функция, выполнение приостанавливается. Взамен начинается выполнение кода функции. Управление в вызывающий код происходит при помощи оператора return или если закончились команды в функции. Оператор return без значения возвращает None.

Оператор yield отправляет результрующий объект вызывающему коду, но место остановки в функции запоминается.

Оператор global применятся для объявления переменных уровня модуля. Функция может обратиться к переменным вызывающего кода за значением, например, чтобы вывести их в консоль. Но присвоить значение этим переменным просто так нельзя, вместо них значение присвоится локальным переменным. При помощи оператора global внутри функции можно обозначить переменные вызывающего кода, которым можно присвоить значение внутри вызываемой функции.

Оператор nonlocal делает не понятно что.

Аргументы в функцию передаются по ссылке. Для неизменяемых на месте типов, это нестрашно. Но передача в функцию такого типа данных как, например, список, приведет к тому, что аргументу фунции назначится ссылка на этот список и все изменения со списком внутри функции произойдут на самом деле.


Замыкания

В пайтон замыкания позволяют передать помимо функции, еще и область видимости, доступную только этой функции. Замыкания можно намутить как с применением def, так и с применением lambda:

def f1():
    x = 5
    def f2():
        print(x)
    return f2

a = f1()
a() -> напечатается 5

def f1(x):
    return lambda n: x + n

a = f1(2) # Вместо x внутри lambda подставляется 2 и так там и остается
a(4) -> # Вместо n подставляется 4. Вернется 6

lambda применяется для создания функции в одну строку, а также этот оператор возвращает ссылку на созданную функцию:
a = lambda x, y: x + y # x и y являются входными параметрами. Можно и вообще без них обойтись
a(10, 15) -> 25

Существует одно исключение:
Если определить внутри цикла функцию или лямбу, в которых некая переменная будет ссылаться на меняющуюся переменную из цикла, например так:
def f1():
    a = []
    for i in range(10):
        a.append(lambda: print(i))
    return a

То в итоге в лямбду попадет лишь последние из итерируемых значений цикла. Все функции в списке a из пиведенного выше примера будут выводить в консоль 9

Аналогично происходит и с def:
def f1():
    a = []
    def f2():
        print(i)
    for i in range(10):
        a.append(f2)
    return a -> все функции из списка напечатают 9

