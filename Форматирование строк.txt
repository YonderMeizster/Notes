Существует несколько способов форматирования строк, причем все виды форматирования неявно производят манипуляции, создают новый объект и уже возвращают ссылку на него.

Один из способов форматирования выглядит следующим образом. Берется строка, в ней пишутся %некий_символ:

%s	подставить сюда то, что выдает метод __str__ объекта
%r	подставить сюда то, что выдает функция repr(), то есть вид литерала, как он бы выглядел в коде
%d	подставить сюда десятичное число (с основанием 10). По сути, вроде как вставляет сюда число с отрезанной дробной частью
%i	подставляет сюда целое число
%o	преобразует целое число в восьмиричный формат и вставляет его
%x	преобразует целое число в шестнадцатеричный формат и вставляет его
%e	приводит к ДРОБНОМУ научному виду, через умножение на 10 в степени ... ('%e' % (10000000000000000) -> 1.000000e+16)
%f	приводит к виду float
%g	приводит к ЦЕЛОЧИСЛЕННОМУ научному виду ('%g' % (10000000000000000) -> 1e+16)
%G	делает то же самое, что и фигня строкой выше, но e становится E
%%	используется для отображения процентов. Умножает число на 100 и приконнективает справа знак %

Собственно, после того, как строка была определена, необходимо после неё поставить знак процента % и затем нарисовать кортеж из элементов, которые встанут на указанные места в строке в указанном через %некий_символ

Этот способ форматирования позволяет использование дополнительных средств форматирования. Наиболее явно и полезно это можно показать на примере с дробями:

'%.0f' % 1.49	-> 1
'%.0f' % 1.5	-> 2
'%.4f' % 1.49	-> 1.4900

До точки - это вся ширина, в которую нужно запихнуть итоговый результат, причем запихивается он в притирку к правой части этой ширины. После точки следует обозначение заданной точности: до какого знака после запятой можно произвести округление

Например:

'%10.1f' % 1.54	-> 0000000000 (ширина, отводимая под запись)	-> 000000001.5 (три символа справа заняты, потому что нужно указать дробную часть)	-> '       1.5' (и вот итоговый результат)

Вместо ширины и точности можно использовать звездочку *. Эта запись заставить интерпретатор искать целое число в последовательности после знака процента % и это число будет подставлено в значение точности или ширины. Например:

'%.*f' (3, 10.12345)	-> 10.123 (тут питон играет злую шутку и округляет не так, как учили в школе. На самом деле змеюка наверняка использует функцию round и пихает её вывод в строку. В общем: round(10.12345, 4) -> 10.1235, но round(10.12345, 3) -> 10.123)

Если вместо положительного значения ширины впихнуть отрицательное, то питон прижмет итоговый литерал влево. Но стоит помнить, если ширина получилась меньше итоговой длины литерала- питон её проигнорирует и отформатирует строку так, будто никакой ширины и не задавалось.

Для форматирования можно применять и словарь со значениями. Для этого необходимо написать литерал так же, как и до этого, но после % в строке наприсовать скобки () и в них нарисовать название переменной. А в словаре в качестве ключа указать строкове представление имени этой переменной:

'%(value1)d, %(value2)s' % {'value1' : 1, 'value2' : 'stroka'}

Еще можно проделать такой финт. Сохранить литерал, поддерживающий форматирование и прибегать к такому форматированию во многих местах кода:

>>> a = '%(value1)d, %(value2)s'
>>> a % {'value1' : 10, 'value2' : 'stroka'}
'10, stroka'
>>> a % {'value1' : 77, 'value2' : 'another_stroka'}
'77, another_stroka'

Подобное форматирование с применением словаря также позволяет задавать ширину и точность для подставляемых значений (в случае строк точность обрезает их до длинны равной указанной точности).

>>> a = '%(value1)10.3f'
>>> a % {'value1' : 32.123456}
'    32.123'

Можно пойти дальше. Существует встроенная функция vars(), возвращающая словарь из названий переменных и их значений. Её можно применить, для того, чтобы элегантно заполнить строку необходимыми значениями:

>>> value1 = 5
>>> value2 = 'stroka'
>>> a = '%(value1)d, %(value2)s'
>>> a % vars()
'5, stroka'

Это может быть крайне полезно при составлении файлов формата JSON, XML и других подобных документов.

Другой способ форматирования.

Этот способ был представлен в версии пайтона 3.0. Рекомендаций по тому, какой из них использовать, нет.

Заключается в вызове метода .format() на объекте строки. Возвращает отформатированную строку. Сам метод format() принимает в себя аргументы, которые затем подставляет в литерал, на котором вызван (образно подставляет, так как строки не изменяются, он создает новый экземпляр с подставленными результатами)

Вот демонстрация работы:

'{}, {}, {}'.format(1, [1, 2, 3], 'stroka') -> '1, [1, 2, 3], stroka'
'{2}, {0}, {1}'.format(1, 2, 3) -> '3, 1, 2'

Нельзя совмещать в одном строков литерале способ автоматической подстановки и ручной:
'{2}, {}, {}'.format(1, 2, 3)

Также можно подставлять значения по названию переменных, которые передаются в метод. А также этот метод можно совмещать с автоматической и ручной подстановками.
'{value1}, {value2}, {value3}'.format(value1 = 1, value2 = 2, value3 = 3)
'{value1}, {}, {}'.format(1, 2, value3 = 3) # но позиционные аргументы обязательно должны быть до задаваемых аргументов

Для простоты можно мысленно разделить эти переменные на два кучи. Одна куча содержит в себе позиционные аргументы, а вторая аргументы, передаваемые по ключевому слову. И из каждой кучи переменные не влияют на другую кучу.

Внутри фигурных скобок, в которые заносятся переменные, можно указывать индексы, а также ключи для словаря. По факту, туда заносятся объекты, так что у этих объектов можно даже вызывать методы. И если эти методы возвращают что- то что имеет метод __str__() или сами представляют собой строку, все будет работать:

>>> import sys
>>> '{.platform}'.format(sys)
'win32'
>>> '{0.platform}'.format(sys)
'win32'
>>> '{[1]}'.format([7, 6])
'2'

Хоть можно указывать индексы при таком форматировании, остается невозможным взять слайс или ввести отрицательный индекс:

>>> '{[-1]}'.format([1, 2])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list indices must be integers or slices, not str
>>> '{[:]}'.format([1, 2])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list indices must be integers or slices, not str

Для дополнительного форматирования пайтон определяет следующий синтаксис (данная конструкция должна использоваться после двоеточия : после идентификации переменной в фигурных скобках):
[[заполнение]выравнивание] [знак] [#] [0] [ширина] [,] [.точность] [код_типа]

код_типа повторяет указанные выше значения, те же самые %f, %i, но только без процента. Например:

'{:2f}'.format(1.123)	-> '1.12'

Без указания кода типа питон сам решит, в каком формате следует заносить результат форматирования в строку:

'{:.2}'.format(1.123)	-> '1.1' # вот говоришь ему "2 знака после запятой. Он кивает головой и делает вот так, по своей извращенной логике".

А так, операции аналогичны:

'{:8.2f}'.format(1.123) -> '    1.12'

Параметр заполнение может быть любым символом, кроме { и }

Параметр выравнивание может принимать следующие значения: <, >, ^ и =. Соответственно: влево, вправо, по центру и указание, что знак числа должен быть перед знаками заполнителями.

>>> '{:^20.5%}'.format(-10.4531)
'    -1045.31000%    '

Еще даже можно вызвать встроенную функцию format(value1, '{}:10.10'). Которая применит форматирование к одному единственному аргументу. На самом деле эта функция вызывает у строки во второй переданной позиции метод .format() и передает туда параметр value1.

