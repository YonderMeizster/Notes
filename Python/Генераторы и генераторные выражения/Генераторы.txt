Генератор является объектом. Генератор появился в результате потребности в хранении множества значений при ограниченном объеме памяти. Генератор помнит лишь последнее значение, которое он выдал, а также знает, как ему получить и выдать новое значение. Еще знает о том, при каких условиях необходимо прекратить выдачу новых значений.

Объект генератора можно создать с помощью генераторного выражения:

>>> gen = (x for x in range(5))
>>> type(gen)
<class 'generator'>

Вызывая метод __next__() у экземпляра- генератора, возващаться будут генерируемые значения:

>>> gen.__next__()
0
>>> gen.__next__()
1
>>> gen.__next__()
2
>>> gen.__next__()
3

Аналогичным образом работает встроенная функция next(), в неё необходимо передать экземпляр генератора, а она внутри себя вызовет метод __next__:

>>> next(gen)
4

Объект генератора можно задействовать в цикле for. В таком случае метод __next__ будет вызываться неявно.

>>> gen = (x for x in range(5))
>>> for i in gen:
...    print(i)		| -> 0, 1, 2, 3, 4

Когда генератор не может выдать новое значение, он выбрасывает исключение StopIteration, которое обрабатывается в цикле for.

Создание генераторов из генераторных выражений является упрощенной процедурой. Также генераторы можно получать из генераторных функций, задействую оператор yield. Например:

def func_gen():
    i = 1
    while True:
        yield i
        i += 1

gen = func_gen()
print(next(gen))	| -> 1
print(next(gen))	| -> 2
print(next(gen))	| -> 3