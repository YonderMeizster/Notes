Для того, чтобы выдавать коллекцию не всю сразу, а по одному куску значений за раз, существуют итераторы.

Итератором в python является экземпляр класса, поддерживающищего протокол итерации. Для этого он должен реализовывать методы __next__ и __iter__.
При вызове метода __next__ итератор выплевывает новое значение. Если нового значения нет- он выплевывает исключение StopIteration. Собственно говоря, контексты итерации (цикл for), вызывают N- ое число раз метод __next__ до тех пор, пока не выбросится исключение, которое контекст обработает.

Метод __iter__ необходим для того, чтобы получить итератор из объекта (некой последовательности). Например:

my_func(10).__iter__() is my_func(10)	| -> True

И то, и то генераторы.

В python 3.3 была добавлена конструкция yield from некий_иетрируемый объект. Данная конструкция позволяет делегировать итерирование на другой генератор. Например, возможна такая конструкция:
yield from [x for x in range(10)]

Метод send позволяет управлять ходом итерации из вызывающего кода. Для того, чтобы воспользоваться этим методом, внутренним методом итератора, необходимо применить не оператор yeild, а выражение yield. Разница между ними заключается в том, что результат выражения yield должен заноситься в переменную: X = yield. В случае, если справа от оператора приравнивания находится не только операция yield, то её необходимо заключать в скобки: X = (yield) + 42 или X = (yield i) + 42.

Из вызывающего кода после такого можно вызвать метод send(), тот аргумент, который передается с методом send, отправляется прямиком в переменную X.
