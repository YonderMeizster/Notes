Операторы в python представлены следующим списком:

global

nonlocal

import

from

class

try/except/finally

raise

assert

with/as

del

:

=

+ - / * **

Операторы можно разбивать на несколько строк, например, так можно объявить список на нескольких строках:

list1 = [
    1,
    2,
]

А так можно объявить переменную для строки на нескольких строках:

stroka1 = ('abc' +
           'def')

Секрет этого прикола в использовании скобок [], (), {}. Но для строк стоит применять только круглые, потому что квадратные приведут к созданию списка с одним элементом строкой, а фигурные скажут интерпретатору о необходимости создания множества с одним элементом.

Этот же метод работает и с другими составными операторамии:

a = (True and
     True or
     False)

Оператор присваивания:
stroka1, stroka2, stroka3 = '123', '321', 'abc'
stroka1, stroka2, stroka3 = ['123', '321', 'abc']
stroka1 = stroka2 = 'abc' # Групповое присваивание
stroka1, *stroka2 = 'stroka' -> stroka1 = 's' и stroka2 = ['t', 'r', 'o', 'k', 'a']

Распаковка последовательности.
Можно распихать последовательность по переменным таки м образом:
a, b = 'ab'
Но вот так уже нелья:
a, b = 'abc' # Возникнет ValueError, говорящий о слишком большом числе элементов в последовательности.
Чтобы таки распихать последовательность из трех элементов по двум переменным, необходимо применить распаковку:
a, *b = 'abc' # в таком случае a = 'a' и b = ['bc']
a*, b = 'abc' # a = ['ab'] и b = 'c'

Имя со звездочкой может находиться и в середине, но сути дела это не меняет. Сперва по переменным без звездочки распихаются значения, а остаток занесется в переменную со звездочкой.

Разрешена лишь одна операция распаковки в операторе присваивания:
a, *b, c, *d = 'abbcdd' # ValueError

При распаковке списков в звездочку закладывается всегда список:
a, *b = [1, 2] # -> b = [2]

Если для переменной со звездочкой не осталось значений, то в неё закладывается пустой список