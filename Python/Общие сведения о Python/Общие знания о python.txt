dir(value1) -> вернет список строк, представляющих собой названия всех аттрибутов (полей и методов объекта value1)

help('stroka'.split) -> возвращает None, но также печатает в консоль справку о методе. В функцию help() должна передаваться именно ссылка на метод, то есть необходимо написать название метода без скобок. Написание метода со скобками приведет к тому, что интепретатор попытается вызвать этот метод

ord('0') -> вернет позицию символа в таблице unicode (48)

chr(48) -> вернет str символа из таблицы юникода ('0')

len(val1) -> вернет длину последовательности

sorted(a) -> отсортирует объект a

reversed(a) -> вернет итератор на сортированную последовательность а

Python контроллирует занимаемую память с помощью сборщика мусора. Этот агрегат, а именно программная абстракция, освобождает память, отведенную объекту, когда на него перестают ссылаться (то есть из области кода к нему уже не обратиться). Например:

1) val1 = [1, 2, 3]
2) val1 = 5

В промежутке между первой и второй строкой отработает сборщик мусора, который удалит из памяти данные о списке [1, 2, 3]

repr() -> возвращает истинное представление строки, показывая специальные последовательности символов \t, \n и другие

Чтобы очистить консоль через питон нужно импортировать модуль os и вызвать метод os.system('cls') (По крайней мере работает в windows). Он прокручивает консоль в vscode, но это уже придумки vscode

При рассчете выражения, например 3 + 3.14 пайтон приводит все типы к более сложным, после чего выполняет операции. Ответом на приведенное выражение будет число дробного типа, вроде бы его еще называют числом с плавающей запятой. Порядок сложности такой (от более простого к более сложному): целые числа -> числа с плавающей точкой -> комплексные числа

Приведение к одному типу в пайтоне выполняется только в отношении вычисления числовых операций. При попытке прибавить к строке число интерпретатор сообщит об ошибке TypeError. Но в то же время при попытке умножить строку на число обратно из выражения вернется новый экземпляр строки, но "повтороенный" столько раз, на какое число было произведено умножение

Одним из показателей полиморфизма в пайтоне служит оператор +. Результат применения этого оператора зависит от объектов, с которыми он используется. Например при сложении чисел получится число, но при сложении двух строк или двух списоков результатом будет конкатенация последовательностей. Данное явления называется "перегрузкой оператора +"

Переменные в пайтоне создаются в момент объявления. А использование переменных возможно только после их создания. Попытка использовать переменную до объявления приведет к появлению ошибки NameError. Это причина, по которой необходимо создавать пустой список или кортеж или так далее... В другом языке, например, C#, также необходимо объявлять переменные до их использования. Но так как сишарп- строготипизированный язык, переменная какого- то может быть объявлена, но может не иметь значения, по этой причине в шарпах помимо объявления переменной ей необходимо еще и назначить значение.

eval(a : str) -> не возвращает ничего, но выполняет то, что расценивает то, что подано на вход как команду. Например eval(input()) исполнит ту команду, которую укажет пользователь в пользовательском вводе

enumerate(list1) -> вернет enumerate объект, предоставляющий пару индек, значение по индексу в list1.
Может быть использовано при итерировании:
for index, value in enumerate('abc'):
    print(f'{} : {}')
0 : 'a'
1 : 'b'
2 : 'c'

Переменные в пайтон почти не отличаются друг от друга. Они являются лишь именами для объектов. И все переменные ведут к своим объектам по ссылкам. Использовать переменные в пайтоне можно только после их инициализации (присвоения значения, а точнее, засовывания в переменную ссылки на объект). До момента инициализации от переменной нет толка. Так как весь смысл переменной в питоне- это указывать на определенные куски памяти, являющиеся объектами. При использовании переменных в выражениях, они тотчас же заменяются объектами, на которые ссылаются. ПЕРМЕННЫЕ ВСЕГДА ССЫЛАЮТСЯ НА ОБЪЕКТЫ И НИКОГДА НА ДРУГИЕ ПЕРЕМЕННЫЕ. В целях оптимизации Python кеширует некоторые неизменяемые объекты, например числа и строки. С помощью функции getrefcount() из модуля sys можно посмотреть на количество ссылок на тот или иной объект:

>>> from sys import getrefcount as getr
>>> for letter in 'abcdef':
...     print(f'letter = {letter} and ref amount = {getr(letter)}')

letter = a and ref amount = 4
letter = b and ref amount = 6
letter = c and ref amount = 11
letter = d and ref amount = 10
letter = e and ref amount = 6
letter = f and ref amount = 7

Каждый объект содержит два интересных в этом плане рассмотрения вопроса поля: счетчик ссылок и обозначение типа. Счетчик ссылок показывает, как много других объектов или переменных ссылаются на этот объект, а обозначение типа дает представление о типе этого объекта.

По- сути в питоне переменные не изменяют свой тип (на строго типизированном языке это выглядело бы как int a превратился бы в string a). Так как тип никак не привязан к переменной, то переменная просто не может менять свой тип по определению. Вместо этого тип связан с объектом. Объект может быть приведен к другому типу, но и это не меняет тип объекта, а лишь вынуждает рассматривать этот экземпляр класса с точки зрения полей и методов другого класса.

vars()	-> возвращает словарь из названий переменных в ключах и их значений в значениях по этим ключам

В пайтоне существуют методы, функции и выражения. Методы вызываются через соответствующие объекты, функции похожи на статические методы, а выражения распознаются питоном и выглядят по- особому, ни с чем не спутаешь: выражение для ... % ...- форматирования строки, ... + ... - выражение для сложения и так далее.
Формально в питоне три типа данных: числа (поддерживают сложение, умножение и другие), последовательности (индексируются по порядку, доступны для взаимодействия с операциями среза и конкатенации), отображения (индексируются по ключу)
Также данные могут быть неизменяемыми и изменяемыми. Отсюда происходит еще одно деление: неизменяемые строки - str, изменяемые строки - bytearray

Несколько строковых литералов, разделенных пробелом автоматически конкатенируются. По всей видимости, это сделано с целью упрощения разбиения длинных строк через заключение их в круглые скобки:

stroka = (
    'abc'
    'bcd'
    'fgh'
) # -> 'abcbcdfgh'
