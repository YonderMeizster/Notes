# Flask

## Введение

### Зачем оно нужно, эти ваши фрауворкеры?

Работа современного Интернета, точнее, конкретно Web'а в своей идее проста:
клиент отправляет запрос, сервер его смотрит и в зависимости от найденных
приколюх внутри составляет тот или иной ответ и возваращает его клиенту.

Все сайты работают по одинаковым принципам, в целях уменьшения трудозатрат при
разработке сайтов были разработаны фреймворки. Они берут на себя значительную
часть ответственности, по обеспечению работоспособности ресурса.

Фреймворки можно назвать специализированными библиотеками, определяющими
структуру программы.

### Возможности Flask

Flask можно считать микрофреймворком, посколько в сравнении с Django он обладает
скудным функционалом. Но при этом Flask умеет:

- Парсить входящие HTTP запросы, производить маршрутизацию по адресу, глаголу
  HTTP, параметрам запроса;
- Формировать ответы на запросы, которые содержат нужные статус, заголовки,
  cookies, данные в необходимом формате;
- Работать с сессиями;
- Работать с шаблонизатором.

Для справки:

- Flask не содержит встроенной ORM;
- Не возможно обрабатывать форму ввода и валидации данных;
- Не прикуртить админку встроенными средствами.

### Первое приложение на Flask

```
from flask import Flask


app = Flask(__name__)

@app.route('/')
def good_day():
    return 'Good day!\n'
```

Переменная app определяется как экземпляр класса Flask. В свою очередь app-
становится приложением, поддерживающим интерфейс WSGI.

Декоратор route() связывает функцию- обработчик (good_day) и конкретный адрес на
сайте.

Вместе с flask поставляется и development сервер. Для запуска этого минимального
приложения следует ввести следующую команду:

```
flask --app good_day run
```

Для удобства можно создать Makefile со следующим содержанием:

```
start:
    flask --app good_day run
```

А затем вызывать через

```
make start
```

Существует и режим отладки, он задается во время запуска:

```
flask --app exmapl --debug run
```

#### **Небольшое отступление про работу make**

Make будет пытаться найти файл с именем Makefile в текущей директории. После
того, как искомый файл будет найден, посмотрит на цели, которые описаны в нем. В
приведенном выше make- файле лишь одна цель- start. **Важно, чтобы действия
внутри цели были отделены tab'ом.**

### Как запустить приложение Flask без утилиты flask

Для этого необходимо вызвать метод .run() у объекта Flask:

```
app = Flask(__name__)

...

if __name__ == '__main__'
    app.run(port = 8000)
```

В метод run можно передать порт, а также host, на котором будет запущено
приложение. Для отладки можно передать True через параметр debug.

## Обработчики запросов и диспетчеризация

### Обработчики

Любой веб- фреймворк работает плюс- минус одинаково. На каждый маршрут задается
свой обработчик, англ. handler. Обработчик представляет собой функцию,
возвращающую результат в виде строки (flask позволяет обработчикам возваращать
еще и словари, списки и кортежи. Соответственно, в других веб- фреймворках может
эта ситуация обстоять иначе).

**Маршрутом зовется совокупность URL и метода.**


В flask обработчики регистрируются с помощью декоратора @route(). Декоратор
принимает путь, для которого вызывается обработчик.

```
@app.route('/')
def index():
    pass


@app.route('/data/users.json')
def users():
    pass
```

Так сложилось, что во фреймворках принято указывать маршрут в виде совокупности
url и методов HTTP. Во Flask существует два способа указания методов:

- Как аргумент декоратора @route(). Все указанные методы будут обрабатываться одной
  функцией:

```
@app.route('\', methods = ['GET', 'POST'])
...
```

- Как отдельные обработчики под указанные методы:

```
@app.get('/')
...


@app.post('/')
...
```

### Диспетчеризация

Диспетчеризация в контексте python- объединение нескольких веб- приложений на
уровне WSGI. Под понятие диспетчеризации попадает и процесс поиска подходящего
обработчика под запрос. В итоге диспетчеризация выполняется в два этапа:

1) До входа в конкретное WSGI приложение;
2) После входа в приложение.

До входа в приложение запрос поступает в веб-сервер, веб-сервер перенаправляет
запрос тому или иному wsgi-приложению. Как я понимаю, в зависимости от заголовка
host.

После того, как запрос попал в wsgi приложение, приложение анализирует заголовки
и пытается найти подходищий маршрут в роутере (роутер- файлик, в котором
хранятся все маршруты), в случае, если маршрута не найдено- возвращается код
404. В ином случае вызывается подходящий обработчик. Причем стандартно
считается, что обработчик вызывается для метода GET. Это может сыграть роль в
ситуации, в которой существует некий путь, но для него задан лишь обработчик
POST. В случае, если попытаться обратиться к этому пути с запросом GET- вернется
код 405 Method Not Allowed.

#### Можно ли посмотреть маршруты в flask- приложении?

Можно, через команду

```
user@coding:~$ flask --app good_day routes
Endpoint  Methods  Rule
--------  -------  -----------------------
good_day  GET      /
static    GET      /static/<path:filename>
```

## HTTP- сессия

### Request и response

Во Flask пристутствует глобальный объект request, который отображает в себе
входящий запрос. Также существует и объект response, содержащий ответ.

Response формируется автоматически:

```
@app.route('/json/')
def json():
    return {'key' : 1} # в заголовке выставится тип application/json


@app.route('/html/')
def html():
    return render_template('index.html') # text/html
```

Если обработчик возвращает кортеж из числа и строки, то клиент получит код
ответа:

```
@app.route('/not_found')
def not_found():
return 'Not found', 404
```

Во Flask обработчики ошибок выглядят так же, как и обычные обработчики. Разница
в том, что обработчик ошибок получает в качестве аргумента объект ошибки.

```
@app.errorhandler(404)
def not_found(error):
    return 'Запрашиваемой страницы не найено', 404
```

В случае, если необходимо вручную настроить ответ, следует использовать функцию
make_response:

```
from flask import make_response


@app.route('/foo')
def foo():
    r = make_response('foo')
    r.headers['header 1'] = 'header 1'
    r.mimetype = 'text/plain'
    r.status_code = 200
    r.set_cookie('foo', 'bar')
    return r
```

Функция make_response применяется для установки необходимых заголовков. На вход
функции подается результат работы функции представления (строка, или, к примеру,
результат render_template()), а он возвращает объект типа response. Который
можно отправить клиенту.

### Параметры запроса

Освежим в памяти: параметры запроса, это query string. Параметры, передаваемые в
request line. Представляют собой перечисление ключ=значение после
вопросительного знака после указания URN (пути, например /index?...)

Так вот, различие в этих самых параметрах запроса не ведет к дифференциации
путей. Путь остается одним и тем же, следовательно, обработчик также один и тот
же. Вот только возвращаемые данные зависят от передаваемых параметров в запросе.

Парсинг аргументов происходит через request.args[название аргумента], в таком
случае, если аргумент не найден- сервер вернет 404. Другой способ парсинга
заключается в вызове метода get аттрибута args у объекта request:
request.args.get(имя аргумента, default=None, type=None). Параметр type
позволяет привести возвращаемое значение к определенному типу. Если не удается
привести значение к этому типу- возникнет ValueError.

> Что за args такой? args являсь аттрибутом объекта request представляет собой
> экземпляр класса ImmutableMultiDict, поэтому он ведет себя как словарь, но при
> этом метод get() у него слегка другой.

```
@app.route('/parse_args')
def args():
    arg = request.args['arg']
    arg = request.args.get('arg', 0, int)
    return f'Переданный аргумент arg равен {arg}'
```

## Динамические маршруты

Динамическими являются те два маршрута, которые отличаются между собой, но при
этом могут быть обработаны одним обработчиком.

Во Flask обработчик для динамического маршрута задается следующим образом: все
как обычно, но изменяемая часть в URL содержится в угловых скобках, а в функция
под декоратором должна принимать параметр тот самый изменяемый параметр:

```
@app.route('/users/<id>')
def users(id):
    return f'User ID is {id}'
```

Можно даже делать так:

```
@app.route('/user<id>')
def users(id):
    pass
```

То есть, изменяемая часть не обязана находиться между двумя слешами. Также не
могу не отметить факт того, что название изменяемой части должно соответствовать
названию аргумента функции. В противном случае возникнет TypeError на сервере.

Настала пора как- то обозвать это чудо, носит оно гордое название
**плейсхолдер**. Плейсхолдером является любая изменяемая часть в марщруте.
Причем **плейсхолдер- сердцевина, заключенная в угловые скобки**.

Для удобства в адресах стараются использовать не числовые идентификаторы, а
какие- то более- менее осмысленные названия. Эта сущность зовется **slug**. К
примеру, вместо /user/1 используется более осмысленное /user/denis. Остается,
надеяться, что Денис- уникальный пользователь, иначе придется сохранить
/user/denis, но добавить /user/denis1 и других Денисов.

Slug должен быть уникальным, для его формирования следует применять символы
англосаксов в нижнем регистре, разделенные тире '-'. Кажется, это называется
kebab-case.

Если не вдаваться в детали, то slug- попросту кусок URL в удобном для человека
виде, обозначающий некий ресурс.

Стоит разделять понятия маршрута и адреса. Маршрут может быть статическим и
динамическим (с плейсхолдерами). В первом случае маршрут и адрес совпадают, а во
втором одному маршруту соответствует практически неограниченное количество
адресов.

## Шаблонизатор

Собсна, а мы тут зачем собрались? Мы хотим делать сайты всякие, а для сайтов нам
нужно делать красивые страницы на HTML. Самый простой очевидный способ этого
делания заключается в следующем- запихнуть страницу целиком в одну строку и
возвращать её из обработчика.

Минусов у этого способа навалом, так что мы не будем так поступать, а сделаем
иначе. Будем пользоваться шаблонизаторами. Шаблонизаторы - библиотеки, которые
берут параметры, берут шаблон (заготовка html- страницы) и пихают параметры в
этот шаблон.

Одним из таких шаблонизаторов является библиотека Jinja2, она поставляется с
Flask. А вот так ей можно воспользоваться:

```
from flask import flask, render_template


app = Flask(__name__)


@app.route('/users/<id>')
def users(id):
    return render_template('index.html', id=id)
```

Функция render_templates принимает название шаблона и список именованных аргументов.

Сам файлик index.html лежит в директории ./templates/ и содержит следующее наполнение:

```
<h1>Hello, user {{ id }}</h1>
```

Шаблонизатор Jinja2 поддерживает дополнительные конструкции в html:
- {{...}} - плейсхолдер для переменных;
- {%...%} - плейсхолдер для управления логикой шаблона;
- {#...#} - комментарии.

Второй плейсхолдер позволяет, к примеру, формировать списки, таблицы и прочее
переменной длины внутри:

```
from flask import Flask, render_template


app = Flask(__name__)


@app.route('/users/<id>')
def users(id):
    return render_template('index.html', id=id)


l = ['Элемент 0', 'Элемент 1', 'Элемент 2', 'Элемент N']


@app.route('/list')
def list():
    return render_template('list.html', l=l)
```

А вот содержимое файла list.html:

```
<table>
    {% for element in l %}
    <tr>
      <td>
          {{ element }}
      </td>
    </tr>
    {% endfor %}
</table>
```

