# Flask

## Введение

### Зачем оно нужно, эти ваши фрауворкеры?

Работа современного Интернета, точнее, конкретно Web'а в своей идее проста:
клиент отправляет запрос, сервер его смотрит и в зависимости от найденных
приколюх внутри составляет тот или иной ответ и возваращает его клиенту.

Все сайты работают по одинаковым принципам, в целях уменьшения трудозатрат при
разработке сайтов были разработаны фреймворки. Они берут на себя значительную
часть ответственности, по обеспечению работоспособности ресурса.

Фреймворки можно назвать специализированными библиотеками, определяющими
структуру программы.

### Возможности Flask

Flask можно считать микрофреймворком, посколько в сравнении с Django он обладает
скудным функционалом. Но при этом Flask умеет:

- Парсить входящие HTTP запросы, производить маршрутизацию по адресу, глаголу
  HTTP, параметрам запроса;
- Формировать ответы на запросы, которые содержат нужные статус, заголовки,
  cookies, данные в необходимом формате;
- Работать с сессиями;
- Работать с шаблонизатором.

Для справки:

- Flask не содержит встроенной ORM;
- Не возможно обрабатывать форму ввода и валидации данных;
- Не прикуртить админку встроенными средствами.

### Первое приложение на Flask

```
from flask import Flask


app = Flask(__name__)

@app.route('/')
def good_day():
    return 'Good day!\n'
```

Переменная app определяется как экземпляр класса Flask. В свою очередь app-
становится приложением, поддерживающим интерфейс WSGI.

Декоратор route() связывает функцию- обработчик (good_day) и конкретный адрес на
сайте.

Вместе с flask поставляется и development сервер. Для запуска этого минимального
приложения следует ввести следующую команду:

```
flask --app good_day run
```

Для удобства можно создать Makefile со следующим содержанием:

```
start:
    flask --app good_day run
```

А затем вызывать через

```
make start
```

Существует и режим отладки, он задается во время запуска:

```
flask --app exmapl --debug run
```

#### **Небольшое отступление про работу make**

Make будет пытаться найти файл с именем Makefile в текущей директории. После
того, как искомый файл будет найден, посмотрит на цели, которые описаны в нем. В
приведенном выше make- файле лишь одна цель- start. **Важно, чтобы действия
внутри цели были отделены tab'ом.**

### Как запустить приложение Flask без утилиты flask

Для этого необходимо вызвать метод .run() у объекта Flask:

```
app = Flask(__name__)

...

if __name__ == '__main__'
    app.run(port = 8000)
```

В метод run можно передать порт, а также host, на котором будет запущено
приложение. Для отладки можно передать True через параметр debug.

## Обработчики запросов и диспетчеризация

### Обработчики

Любой веб- фреймворк работает плюс- минус одинаково. На каждый маршрут задается
свой обработчик, англ. handler. Обработчик представляет собой функцию,
возвращающую результат в виде строки (flask позволяет обработчикам возваращать
еще и словари, списки и кортежи. Соответственно, в других веб- фреймворках может
эта ситуация обстоять иначе).

**Маршрутом зовется совокупность URL и метода.**


В flask обработчики регистрируются с помощью декоратора @route(). Декоратор
принимает путь, для которого вызывается обработчик.

```
@app.route('/')
def index():
    pass


@app.route('/data/users.json')
def users():
    pass
```

Так сложилось, что во фреймворках принято указывать маршрут в виде совокупности
url и методов HTTP. Во Flask существует два способа указания методов:

- Как аргумент декоратора @route(). Все указанные методы будут обрабатываться одной
  функцией:

```
@app.route('\', methods = ['GET', 'POST'])
...
```

- Как отдельные обработчики под указанные методы:

```
@app.get('/')
...


@app.post('/')
...
```

### Диспетчеризация

Диспетчеризация в контексте python- объединение нескольких веб- приложений на
уровне WSGI. Под понятие диспетчеризации попадает и процесс поиска подходящего
обработчика под запрос. В итоге диспетчеризация выполняется в два этапа:

1) До входа в конкретное WSGI приложение;
2) После входа в приложение.

До входа в приложение запрос поступает в веб-сервер, веб-сервер перенаправляет
запрос тому или иному wsgi-приложению. Как я понимаю, в зависимости от заголовка
host.

После того, как запрос попал в wsgi приложение, приложение анализирует заголовки
и пытается найти подходищий маршрут в роутере (роутер- файлик, в котором
хранятся все маршруты), в случае, если маршрута не найдено- возвращается код
404. В ином случае вызывается подходящий обработчик. Причем стандартно
считается, что обработчик вызывается для метода GET. Это может сыграть роль в
ситуации, в которой существует некий путь, но для него задан лишь обработчик
POST. В случае, если попытаться обратиться к этому пути с запросом GET- вернется
код 405 Method Not Allowed.

#### Можно ли посмотреть маршруты в flask- приложении?

Можно, через команду

```
user@coding:~$ flask --app good_day routes
Endpoint  Methods  Rule
--------  -------  -----------------------
good_day  GET      /
static    GET      /static/<path:filename>
```

## HTTP- сессия

### Request и response

Во Flask пристутствует глобальный объект request, который отображает в себе
входящий запрос. Также существует и объект response, содержащий ответ.

Response формируется автоматически:

```
@app.route('/json/')
def json():
    return {'key' : 1} # в заголовке выставится тип application/json


@app.route('/html/')
def html():
    return render_template('index.html') # text/html
```

Если обработчик возвращает кортеж из числа и строки, то клиент получит код
ответа:

```
@app.route('/not_found')
def not_found():
return 'Not found', 404
```

Во Flask обработчики ошибок выглядят так же, как и обычные обработчики. Разница
в том, что обработчик ошибок получает в качестве аргумента объект ошибки.

```
@app.errorhandler(404)
def not_found(error):
    return 'Запрашиваемой страницы не найено', 404
```

В случае, если необходимо вручную настроить ответ, следует использовать функцию
make_response:

```
from flask import make_response


@app.route('/foo')
def foo():
    r = make_response('foo')
    r.headers['header 1'] = 'header 1'
    r.mimetype = 'text/plain'
    r.status_code = 200
    r.set_cookie('foo', 'bar')
    return r
```

Функция make_response применяется для установки необходимых заголовков. На вход
функции подается результат работы функции представления (строка, или, к примеру,
результат render_template()), а он возвращает объект типа response. Который
можно отправить клиенту.

### Параметры запроса

Освежим в памяти: параметры запроса, это query string. Параметры, передаваемые в
request line. Представляют собой перечисление ключ=значение после
вопросительного знака после указания URN (пути, например /index?...)

Так вот, различие в этих самых параметрах запроса не ведет к дифференциации
путей. Путь остается одним и тем же, следовательно, обработчик также один и тот
же. Вот только возвращаемые данные зависят от передаваемых параметров в запросе.

Парсинг аргументов происходит через request.args[название аргумента], в таком
случае, если аргумент не найден- сервер вернет 404. Другой способ парсинга
заключается в вызове метода get аттрибута args у объекта request:
request.args.get(имя аргумента, default=None, type=None). Параметр type
позволяет привести возвращаемое значение к определенному типу. Если не удается
привести значение к этому типу- возникнет ValueError.

> Что за args такой? args являсь аттрибутом объекта request представляет собой
> экземпляр класса ImmutableMultiDict, поэтому он ведет себя как словарь, но при
> этом метод get() у него слегка другой.

```
@app.route('/parse_args')
def args():
    arg = request.args['arg']
    arg = request.args.get('arg', 0, int)
    return f'Переданный аргумент arg равен {arg}'
```

## Динамические маршруты
