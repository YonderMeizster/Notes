# Flask

## Введение

### Зачем оно нужно, эти ваши фрауворкеры?

Работа современного Интернета, точнее, конкретно Web'а в своей идее проста:
клиент отправляет запрос, сервер его смотрит и в зависимости от найденных
приколюх внутри составляет тот или иной ответ и возваращает его клиенту.

Все сайты работают по одинаковым принципам, в целях уменьшения трудозатрат при
разработке сайтов были разработаны фреймворки. Они берут на себя значительную
часть ответственности, по обеспечению работоспособности ресурса.

Фреймворки можно назвать специализированными библиотеками, определяющими
структуру программы.

### Возможности Flask

Flask можно считать микрофреймворком, посколько в сравнении с Django он обладает
скудным функционалом. Но при этом Flask умеет:

- Парсить входящие HTTP запросы, производить маршрутизацию по адресу, глаголу
  HTTP, параметрам запроса;
- Формировать ответы на запросы, которые содержат нужные статус, заголовки,
  cookies, данные в необходимом формате;
- Работать с сессиями;
- Работать с шаблонизатором.

Для справки:

- Flask не содержит встроенной ORM;
- Не возможно обрабатывать форму ввода и валидации данных;
- Не прикуртить админку встроенными средствами.

### Первое приложение на Flask

```
from flask import Flask


app = Flask(__name__)

@app.route('/')
def good_day():
    return 'Good day!\n'
```

Переменная app определяется как экземпляр класса Flask. В свою очередь app-
становится приложением, поддерживающим интерфейс WSGI.

Декоратор route() связывает функцию- обработчик (good_day) и конкретный адрес на
сайте.

Вместе с flask поставляется и development сервер. Для запуска этого минимального
приложения следует ввести следующую команду:

```
flask --app good_day run
```

Для удобства можно создать Makefile со следующим содержанием:

```
start:
    flask --app good_day run
```

А затем вызывать через

```
make start
```

Существует и режим отладки, он задается во время запуска:

```
flask --app exmapl --debug run
```

#### **Небольшое отступление про работу make**

Make будет пытаться найти файл с именем Makefile в текущей директории. После
того, как искомый файл будет найден, посмотрит на цели, которые описаны в нем. В
приведенном выше make- файле лишь одна цель- start. **Важно, чтобы действия
внутри цели были отделены tab'ом.**

### Как запустить приложение Flask без утилиты flask

Для этого необходимо вызвать метод .run() у объекта Flask:

```
app = Flask(__name__)

...

if __name__ == '__main__'
    app.run(port = 8000)
```

В метод run можно передать порт, а также host, на котором будет запущено
приложение. Для отладки можно передать True через параметр debug.

## Обработчики запросов и диспетчеризация

### Обработчики

Любой веб- фреймворк работает плюс- минус одинаково. На каждый маршрут задается
свой обработчик, англ. handler. Обработчик представляет собой функцию,
возвращающую результат в виде строки (flask позволяет обработчикам возваращать
еще и словари, списки и кортежи. Соответственно, в других веб- фреймворках может
эта ситуация обстоять иначе).

**Маршрутом зовется совокупность URL и метода.**


В flask обработчики регистрируются с помощью декоратора @route(). Декоратор
принимает путь, для которого вызывается обработчик.

```
@app.route('/')
def index():
    pass


@app.route('/data/users.json')
def users():
    pass
```

Так сложилось, что во фреймворках принято указывать маршрут в виде совокупности
url и методов HTTP. Во Flask существует два способа указания методов:

- Как аргумент декоратора @route(). Все указанные методы будут обрабатываться одной
  функцией:

```
@app.route('\', methods = ['GET', 'POST'])
...
```

- Как отдельные обработчики под указанные методы:

```
@app.get('/')
...


@app.post('/')
...
```

### Диспетчеризация

Диспетчеризация в контексте python- объединение нескольких веб- приложений на
уровне WSGI. Под понятие диспетчеризации попадает и процесс поиска подходящего
обработчика под запрос. В итоге диспетчеризация выполняется в два этапа:

1) До входа в конкретное WSGI приложение;
2) После входа в приложение.

До входа в приложение запрос поступает в веб-сервер, веб-сервер перенаправляет
запрос тому или иному wsgi-приложению. Как я понимаю, в зависимости от заголовка
host.

После того, как запрос попал в wsgi приложение, приложение анализирует заголовки
и пытается найти подходищий маршрут в роутере (роутер- файлик, в котором
хранятся все маршруты), в случае, если маршрута не найдено- возвращается код
404. В ином случае вызывается подходящий обработчик. Причем стандартно
считается, что обработчик вызывается для метода GET. Это может сыграть роль в
ситуации, в которой существует некий путь, но для него задан лишь обработчик
POST. В случае, если попытаться обратиться к этому пути с запросом GET- вернется
код 405 Method Not Allowed.

#### Можно ли посмотреть маршруты в flask- приложении?

Можно, через команду

```
user@coding:~$ flask --app good_day routes
Endpoint  Methods  Rule
--------  -------  -----------------------
good_day  GET      /
static    GET      /static/<path:filename>
```