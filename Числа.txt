При сравнении чисел пайтон позволяет указывать диапазон: A < B < C

Операцию // в отношении чисел принято называть целочисленным делением, или усекающим делением. Но правильнее говорить, что то операция деления с округлением в меньшую сторону. Это становится явно видно при делении отрицательных чисел:
-5 // 2 = -3, а не -2

Для перевода числа в другую систему счисления применяются встроенные функции:
oct(), hex(), bin()

Для перевода строки чисел в целочисленный тип применяется функция int(a), где a- строка чисел

Работа с числами в питоне- иллюзия. Например, команда print(0.1 + 0.1) напечатает в консоли 0.2, но команда print(0.1 + 0.1 + 0.1) напечатает уже 0.30000000000000004. Пайтон в этом не виноват, за тем небольшим исключением, что он скрывает реальное положение вещей, печатая 0.1 + 0.1 как 0.2. На самом деле проблема фундаментальна. Точно также, как невозможно истинно представить простую дробь 1/3 в десятичном виде (0.3 или 0.333 или 0.33333333), также невозможно истинно представить в двоичном виде десятичную дробь 0.1. На самом деле дробь 0.1 преддставляется памяти компьютера в виде, крайне приближенном, но все таки не истинном. До некоторого момента пайтон печатает представление дроби в удобоваримом формате для пользователя, как это было показано в начале этого абзаца. Но при дальнейших операциях с плавающей точкой каждый раз нарастает неточность, накапливается ошибка округления. А это приводит, в свою очередь к появлению подобных казусов:

>>> 0.1 + 0.1 == 0.2
True
>>> 0.1 + 0.1 + 0.1 == 0.3
False
>>> 0.1 + 0.2 == 0.3
False

Для обычных житейских задач, встроенный	 инструментарий питона вполне достаточен, чтобы выполнять рассчеты с плавающей точкой и не заботиться о погрешности при округлении. Правда, при сравнении дробных чисел стоит помнить о таком нюансе и применять хитрость: сравнивать не сами дроби, а их разность с неким маленьким числом:

>>> 0.1 + 0.2 - 0.3 < 0.0000000000000001
True

Для особо точных рассчетов необходимо применять модуль decimal:

>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.2') == Decimal('0.3')
True

>>> Decimal('0.1236788921231245645667') + Decimal('0.1236788921231245645667') + Decimal('0.1236788921231245645667') - 3 * Decimal('0.1236788921231245645667') == Decimal('0')
True

Также существует класс Fraction из модуля fractions. Этот класс предоставляет обертку для дробных чисел. Его также можно использовать для увеличения точности вычислений:

>>> from fractions import Fraction
>>> Fraction(1, 3) + Fraction(1, 3) + Fraction(1, 3) == 1
True

Чтобы вычленить числитель и знаменатель из дроби, возможно использовать встроенный метод .as_integer_ratio() у типа float. Правда, его результаты такие же непредсказуемые :/

>>> 2.5.as_integer_ratio()
(5, 2)
>>> 0.3.as_integer_ratio()
(5404319552844595, 18014398509481984)