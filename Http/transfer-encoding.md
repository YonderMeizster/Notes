# Transfer-Encoding или как передать большой объем информации по HTTP

Тривиальный способ решения этой хадачи состоит в следующем: необходимо загрузить
весь файл в оперативную память на сервере, вычислить количество байт в нем,
выставить соответствующий заголовок и запихнуть его в один пакет. На клиенте
этот файл появится в один момент после того, как такой большой http пакет будет
принят.

Проблема видна, но помимо неё существует и другая: а какого размера потоковая
видеотрансляция? Нужно сперва подождать её завершения, чтобы показать её
клиенту?

Ответ есть- будем передавать файл кусками, а не целиком. Для этого существует
заголовок Transfer-Encoding:

```
Transfer-Encoding: chunked
```

А вот пример:

```
GET https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx HTTP/1.1
Host: httpwatch.com
Connection: close

HTTP/1.1 200 OK
Connection: close
Content-Type: image/jpeg; charset=utf-8
Date: Tue, 04 Apr 2023 18:33:16 GMT
Server: Microsoft-IIS/10.0
Cache-Control: no-cache, no-store
Expires: -1
Pragma: no-cache
Trailer: X-HttpWatch-Sample
Transfer-Encoding: chunked
X-AspNet-Version: 4.0.30319
X-Powered-By: ASP.NET
Arr-Disable-Session-Affinity: True

400
Бинарные данные чанка
400
Бинарные данные чанка
400
Бинарные данные чанка
...
375
Последний чанк,имеющий данные
0
Самый последний чанк

Connection closed by foreign host.
```

Сервер передает клиенту картинку, причем по чанкам. Сперва он уведомляет клиента
о численном количестве чанков, после чего осуществляет передачу заданного
объема. Окончание передачи означает два символа перевода строки.

Обхявление размера чанка и сам чанк разделяют символы CRLF: \r\n.