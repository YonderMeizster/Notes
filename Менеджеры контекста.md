# Менеджеры контекста
Менеджеры контеста позволяют выделять и освобождать ресурсы по необходимости.

***
Рассмотрим пример, пример заключается в том, что хотим что- нибудь написать в файл. Сделать это
можно следующим образом:

```
file1 = opent('filex.txt', 'w')
file1.write('some info')
file1.close()
```

Способ вполне рабочий, но имеет несколько недостатков.
1) Необходимо вручную записать файл после того, как была произведена запись;
2) В случае возникновения ошибки во время записи, вылетит исключение и файл закрыт не будет, значит,
   информация не сохранится.
***

Возможно улучшить код из примера выше, обработав второй пункт:

```
file1 = open('file.xt', 'w')
try:
    file1.write('some info')
finally:
    file1.close()
```

Данный код решает проблему с возможной потерей данных при появлении ошибки во время записи в файл.
Но требует написания дополнительных строк кода

А вот далее представлено уже использование контекстного менеджера, который закроет файл в случае
возникновения ошибки при записи:

```
with open('file1.txt', 'w') as file1:
    file1.write('some info')
```

## Создание своего контекстного менеджера

Если стоит задача работать с сущностью, а эта работа требует особого подхода, к примеру: загрузить в
память, проработать и сохранить. То логичным подспорьем в этой задачей станет реализация своего
собственного контекстного менеджера.

В таком случае с это сущностью работа будет вестись через конструкцию with ... as ... Всю головную
боль нужно будет учитывать лишь при реализации протокола контестного менеджера. В дальнейшем сколь
угодно большой объем работы с сущностью будет обезопасен от человеческого фактора (в этом
отношении).

Для этого необходимо добавить в класс два метода:
- \_\_enter\_\_
- \_\_exit\_\_

Каков алгоритм работы контекстного менеджера из примера выше?

1) Оператор with вынуждает python запомнить метод \_\_exit\_\_ класса File;
2) Вызывается метод \_\_enter\_\_ класса file;
3) \_\_enter\_\_ открывает файл и возвращает его
4) Дескриптор передается в file1;
5) 'some info' записывается в file1 посредством метода write();
6) Контекстный менеджер вызывает метод \_\_exit\_\_ и закрывает файл.
7) В случае возникновения исключения при записи в файл, оно передается обрабатывается в методе
   \_\_exit\_\_, а файл закрывается


